<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ゲーム</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        #game-container {
            border: 2px solid #333;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            background-color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            /* Responsive sizing */
            width: 90vw; /* Take up 90% of viewport width */
            max-width: 800px; /* But not larger than original game width */
            aspect-ratio: 4 / 3; /* Maintain 4:3 aspect ratio (800/600) */
            height: auto; /* Let height adjust based on aspect ratio */
            position: relative; /* For absolute positioning of controls */
        }

        canvas {
            background-color: #87CEEB;
            display: block;
            border-radius: 4px;
            touch-action: none;
            /* Fill the container */
            width: 100%;
            height: 100%;
        }

        #game-info {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            font-size: 1.2em; /* This font size will not scale with canvas, but with viewport */
            font-weight: bold;
            color: #333;
        }

        #game-clear-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 2em;
            text-align: center;
            z-index: 100;
            border-radius: 8px;
        }

        #game-clear-screen p {
            margin: 10px 0;
            padding: 10px 20px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        /* On-screen controls styling */
        #on-screen-controls {
            position: absolute;
            bottom: 20px; /* Adjust as needed */
            left: 0;
            right: 0;
            padding: 0 20px;
            display: flex; /* Initially visible */
            justify-content: space-between;
            align-items: flex-end;
            z-index: 50; /* Above canvas, below clear screen */
            /* pointer-events is controlled by JS now */
        }

        #left-right-buttons {
            display: flex;
            gap: 15px; /* Space between left and right buttons */
        }

        .control-button {
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: 2px solid #fff;
            border-radius: 50%; /* Make them round */
            width: 70px; /* Size for touch targets */
            height: 70px;
            font-size: 1.8em;
            font-weight: bold;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            transition: background-color 0.1s ease, transform 0.1s ease;
            -webkit-tap-highlight-color: transparent; /* Remove tap highlight */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .control-button:active {
            background-color: rgba(0, 0, 0, 0.8);
            transform: scale(0.95);
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-info">
            <span id="stage-display">Stage: 1</span>
        </div>
        <canvas id="gameCanvas"></canvas>

        <!-- On-screen control buttons -->
        <div id="on-screen-controls">
            <div id="left-right-buttons">
                <button id="leftButton" class="control-button">◀</button>
                <button id="rightButton" class="control-button">▶</button>
            </div>
            <button id="jumpButton" class="control-button">Jump</button>
        </div>

        <div id="game-clear-screen" style="display:none;">
            <p>ゲームクリア！</p>
            <p>Enterキーで再スタート</p>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const stageDisplay = document.getElementById('stage-display');
        const gameClearScreen = document.getElementById('game-clear-screen');

        // Get on-screen control elements
        const leftButton = document.getElementById('leftButton');
        const rightButton = document.getElementById('rightButton');
        const jumpButton = document.getElementById('jumpButton');
        // Fix: Changed 'onScreenControls' to 'on-screen-controls' to match HTML ID
        const onScreenControls = document.getElementById('on-screen-controls');

        // Internal game world dimensions (fixed, for game logic)
        const GAME_WORLD_WIDTH = 800;
        const GAME_WORLD_HEIGHT = 600;

        // Physics constants remain relative to game world
        const ACC = 0.5;
        const FRIC = -0.15;
        const PLAYER_START_Y_OFFSET = 50;

        // Game state constants
        const GAME_STATE_PLAYING = 0;
        const GAME_STATE_CLEAR = 1;

        let gameState = GAME_STATE_PLAYING;
        // True if the current input mode is keyboard, false for touch/mouse, or gamepad
        let inputMode = 'touch'; // 'touch', 'keyboard', 'gamepad'

        // Gamepad related variables
        let gamepadIndex = null; // Stores the index of the connected gamepad

        // Function to update canvas drawing dimensions
        function updateCanvasDrawingSize() {
            // Set the canvas element's internal resolution to its displayed size
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
        }

        // Initial setup
        updateCanvasDrawingSize();
        window.addEventListener('resize', updateCanvasDrawingSize);


        class Vec2 {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            add(other) {
                return new Vec2(this.x + other.x, this.y + other.y);
            }
            sub(other) {
                return new Vec2(this.x - other.x, this.y - other.y);
            }
            mul(scalar) {
                return new Vec2(this.x * scalar, this.y * scalar);
            }
            copy() {
                return new Vec2(this.x, this.y);
            }
        }

        class Player {
            constructor() {
                this.width = 30;
                this.height = 30;
                this.color = '#3DFFD0';
                this.pos = new Vec2(0, 0);
                this.vel = new Vec2(0, 0);
                this.acc = new Vec2(0, 0);
                this.onGround = false;
            }

            draw() {
                // Calculate scaling factors for drawing
                const scaleX = canvas.width / GAME_WORLD_WIDTH;
                const scaleY = canvas.height / GAME_WORLD_HEIGHT;

                ctx.fillStyle = this.color;
                ctx.fillRect(
                    (this.pos.x - this.width / 2) * scaleX,
                    (this.pos.y - this.height / 2) * scaleY,
                    this.width * scaleX,
                    this.height * scaleY
                );
            }

            handleKeys(keysPressed) {
                this.acc.x = 0;
                if (keysPressed['ArrowLeft'] || keysPressed['a']) {
                    this.acc.x = -ACC * 1.5;
                }
                if (keysPressed['ArrowRight'] || keysPressed['d']) {
                    this.acc.x = ACC * 1.5;
                }
            }

            jump() {
                if (this.onGround) {
                    this.vel.y = -10;
                    this.onGround = false;
                }
            }

            update(platforms, spikes, gameManager, keysPressed) {
                this.handleKeys(keysPressed);
                this.acc.x += this.vel.x * FRIC;
                this.acc.y = ACC;

                this.vel.x += this.acc.x;
                this.pos.x += this.vel.x + 0.5 * this.acc.x;

                // Boundary checks relative to GAME_WORLD_WIDTH
                if (this.pos.x < this.width / 2) {
                    this.pos.x = this.width / 2;
                    this.vel.x = 0;
                }
                if (this.pos.x > GAME_WORLD_WIDTH - this.width / 2) {
                    gameManager.nextStage();
                    return;
                }

                platforms.forEach(platform => {
                    if (this.checkCollision(this.pos.x, this.pos.y, platform)) {
                        if (this.vel.x > 0) {
                            this.pos.x = platform.x - this.width / 2;
                        } else if (this.vel.x < 0) {
                            this.pos.x = platform.x + platform.width + this.width / 2;
                        }
                        this.vel.x = 0;
                    }
                });

                this.vel.y += this.acc.y;
                this.pos.y += this.vel.y + 0.5 * this.acc.y;
                
                this.onGround = false;
                platforms.forEach(platform => {
                    if (this.checkCollision(this.pos.x, this.pos.y, platform)) {
                        if (this.vel.y > 0) {
                            this.pos.y = platform.y - this.height / 2;
                            this.vel.y = 0;
                            this.onGround = true;
                        } else if (this.vel.y < 0) {
                            this.pos.y = platform.y + platform.height + this.height / 2;
                            this.vel.y = 0;
                        }
                    }
                });

                spikes.forEach(spike => {
                    if (this.checkCollision(this.pos.x, this.pos.y, spike)) {
                        gameManager.resetCurrentStage();
                        return;
                    }
                });

                // Fall detection relative to GAME_WORLD_HEIGHT
                if (this.pos.y > GAME_WORLD_HEIGHT + this.height / 2) {
                    gameManager.resetCurrentStage();
                    return;
                }
            }

            checkCollision(playerX, playerY, obj) {
                const playerLeft = playerX - this.width / 2;
                const playerRight = playerX + this.width / 2;
                const playerTop = playerY - this.height / 2;
                const playerBottom = playerY + this.height / 2;

                const objLeft = obj.x;
                const objRight = obj.x + obj.width;
                const objTop = obj.y;
                const objBottom = obj.y + obj.height;

                return playerRight > objLeft && playerLeft < objRight &&
                       playerBottom > objTop && playerTop < objBottom;
            }
        }

        class Platform {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = '#000000';
            }

            draw() {
                const scaleX = canvas.width / GAME_WORLD_WIDTH;
                const scaleY = canvas.height / GAME_WORLD_HEIGHT;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x * scaleX, this.y * scaleY, this.width * scaleX, this.height * scaleY);
            }
        }

        class Spike {
            constructor(x, y, width, height) {
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                this.color = '#FF0000';
            }

            draw() {
                const scaleX = canvas.width / GAME_WORLD_WIDTH;
                const scaleY = canvas.height / GAME_WORLD_HEIGHT;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x * scaleX, this.y * scaleY, this.width * scaleX, this.height * scaleY);
            }
        }

        class GameManager {
            constructor() {
                this.player = new Player();
                this.platforms = [];
                this.spikes = [];
                this.currentStageIndex = 0;
                this.playerStartPosCurrentStage = new Vec2(0, 0);

                this.BASE_STAGE_PATTERNS = [
                    // Stage 1: Basic platforms with a few gaps and spikes on the ground.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 150, 20],
                            [200, GAME_WORLD_HEIGHT - 100, 80, 20],
                            [400, GAME_WORLD_HEIGHT - 150, 100, 20],
                            [550, GAME_WORLD_HEIGHT - 20, 250, 20]
                        ],
                        spikes: [
                            [150, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [300, GAME_WORLD_HEIGHT - 20, 200, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 2: Longer ground platform with elevated platforms and a few ground spikes.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, GAME_WORLD_WIDTH, 20],
                            [100, GAME_WORLD_HEIGHT - 100, 150, 20],
                            [300, GAME_WORLD_HEIGHT - 180, 120, 20],
                            [550, GAME_WORLD_HEIGHT - 100, 100, 20],
                            [700, GAME_WORLD_HEIGHT - 200, 80, 20]
                        ],
                        spikes: [
                            [200, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [400, GAME_WORLD_HEIGHT - 140, 50, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 3: Multiple elevated platforms with varying heights and scattered spikes.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, GAME_WORLD_WIDTH, 20],
                            [50, GAME_WORLD_HEIGHT - 150, 100, 20],
                            [250, GAME_WORLD_HEIGHT - 250, 150, 20],
                            [450, GAME_WORLD_HEIGHT - 150, 100, 20],
                            [600, GAME_WORLD_HEIGHT - 300, 180, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [300, GAME_WORLD_HEIGHT - 200, 50, 20],
                            [650, GAME_WORLD_HEIGHT - 40, 50, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 4: Ground level with several spike pits. Requires precise jumps.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [200, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [400, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [600, GAME_WORLD_HEIGHT - 20, 200, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [300, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [500, GAME_WORLD_HEIGHT - 20, 100, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 5: Ascending platforms with spikes below, requiring careful vertical movement.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [150, GAME_WORLD_HEIGHT - 80, 100, 20],
                            [300, GAME_WORLD_HEIGHT - 140, 100, 20],
                            [450, GAME_WORLD_HEIGHT - 200, 100, 20],
                            [600, GAME_WORLD_HEIGHT - 260, 150, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 40, 20, 20],
                            [200, GAME_WORLD_HEIGHT - 100, 20, 20],
                            [350, GAME_WORLD_HEIGHT - 160, 20, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 6: Mixed height platforms with spikes strategically placed.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 150, 20],
                            [200, GAME_WORLD_HEIGHT - 100, 100, 20],
                            [350, GAME_WORLD_HEIGHT - 20, 150, 20],
                            [550, GAME_WORLD_HEIGHT - 100, 100, 20],
                            [700, GAME_WORLD_HEIGHT - 180, 100, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [225, GAME_WORLD_HEIGHT - 120, 50, 20],
                            [400, GAME_WORLD_HEIGHT - 40, 50, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 7: Alternating high and low platforms with spikes.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [150, GAME_WORLD_HEIGHT - 100, 100, 20],
                            [300, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [450, GAME_WORLD_HEIGHT - 100, 100, 20],
                            [600, GAME_WORLD_HEIGHT - 20, 200, 20]
                        ],
                        spikes: [
                            [175, GAME_WORLD_HEIGHT - 120, 50, 20],
                            [325, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [475, GAME_WORLD_HEIGHT - 120, 50, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 8: Stepping stone platforms with spikes in between.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [150, GAME_WORLD_HEIGHT - 80, 80, 20],
                            [280, GAME_WORLD_HEIGHT - 140, 80, 20],
                            [410, GAME_WORLD_HEIGHT - 200, 80, 20],
                            [540, GAME_WORLD_HEIGHT - 260, 100, 20],
                            [680, GAME_WORLD_HEIGHT - 320, 120, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [230, GAME_WORLD_HEIGHT - 80, 50, 20],
                            [360, GAME_WORLD_HEIGHT - 140, 50, 20],
                            [490, GAME_WORLD_HEIGHT - 200, 50, 20],
                            [620, GAME_WORLD_HEIGHT - 260, 50, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 9: Narrow platforms with spikes in gaps, challenging precision.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 80, 20],
                            [150, GAME_WORLD_HEIGHT - 80, 60, 20],
                            [280, GAME_WORLD_HEIGHT - 140, 60, 20],
                            [400, GAME_WORLD_HEIGHT - 200, 60, 20],
                            [550, GAME_WORLD_HEIGHT - 260, 80, 20],
                            [700, GAME_WORLD_HEIGHT - 320, 100, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [220, GAME_WORLD_HEIGHT - 100, 60, 20],
                            [370, GAME_WORLD_HEIGHT - 160, 50, 20],
                            [480, GAME_WORLD_HEIGHT - 220, 70, 20]
                        ],
                        start_pos: new Vec2(40, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 10: V-shaped spike pits on the ground.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 80, 20],
                            [150, GAME_WORLD_HEIGHT - 100, 50, 20],
                            [250, GAME_WORLD_HEIGHT - 180, 50, 20],
                            [350, GAME_WORLD_HEIGHT - 260, 50, 20],
                            [450, GAME_WORLD_HEIGHT - 180, 50, 20],
                            [550, GAME_WORLD_HEIGHT - 100, 50, 20],
                            [650, GAME_WORLD_HEIGHT - 20, 150, 20]
                        ],
                        spikes: [
                            [80, GAME_WORLD_HEIGHT - 20, 70, 20],
                            [200, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [300, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [400, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [500, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [600, GAME_WORLD_HEIGHT - 20, 50, 20]
                        ],
                        start_pos: new Vec2(40, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 11: Ascending platforms with ground spikes.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [200, GAME_WORLD_HEIGHT - 100, 80, 20],
                            [350, GAME_WORLD_HEIGHT - 180, 80, 20],
                            [500, GAME_WORLD_HEIGHT - 260, 80, 20],
                            [650, GAME_WORLD_HEIGHT - 20, 150, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [280, GAME_WORLD_HEIGHT - 20, 70, 20],
                            [430, GAME_WORLD_HEIGHT - 20, 70, 20],
                            [580, GAME_WORLD_HEIGHT - 20, 70, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 12: Stair-like platforms with small spikes on each step.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 80, 20],
                            [100, GAME_WORLD_HEIGHT - 60, 80, 20],
                            [200, GAME_WORLD_HEIGHT - 100, 80, 20],
                            [300, GAME_WORLD_HEIGHT - 140, 80, 20],
                            [400, GAME_WORLD_HEIGHT - 180, 80, 20],
                            [500, GAME_WORLD_HEIGHT - 220, 80, 20],
                            [600, GAME_WORLD_HEIGHT - 260, 200, 20]
                        ],
                        spikes: [
                            [80, GAME_WORLD_HEIGHT - 40, 20, 20],
                            [150, GAME_WORLD_HEIGHT - 80, 20, 20],
                            [250, GAME_WORLD_HEIGHT - 120, 20, 20],
                            [350, GAME_WORLD_HEIGHT - 160, 20, 20],
                            [450, GAME_WORLD_HEIGHT - 200, 20, 20],
                            [550, GAME_WORLD_HEIGHT - 240, 20, 20]
                        ],
                        start_pos: new Vec2(40, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 13: High platforms with spikes in the gaps, requiring long jumps.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [150, GAME_WORLD_HEIGHT - 100, 80, 20],
                            [300, GAME_WORLD_HEIGHT - 180, 80, 20],
                            [450, GAME_WORLD_HEIGHT - 260, 80, 20],
                            [600, GAME_WORLD_HEIGHT - 340, 100, 20],
                            [700, GAME_WORLD_HEIGHT - 20, 100, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [200, GAME_WORLD_HEIGHT - 120, 50, 20],
                            [350, GAME_WORLD_HEIGHT - 200, 50, 20],
                            [500, GAME_WORLD_HEIGHT - 280, 50, 20],
                            [650, GAME_WORLD_HEIGHT - 360, 50, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 14: Descending platforms with spikes below.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 150, 20],
                            [200, GAME_WORLD_HEIGHT - 80, 100, 20],
                            [350, GAME_WORLD_HEIGHT - 140, 100, 20],
                            [500, GAME_WORLD_HEIGHT - 200, 100, 20],
                            [650, GAME_WORLD_HEIGHT - 260, 150, 20]
                        ],
                        spikes: [
                            [150, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [300, GAME_WORLD_HEIGHT - 100, 50, 20],
                            [450, GAME_WORLD_HEIGHT - 160, 50, 20],
                            [600, GAME_WORLD_HEIGHT - 220, 50, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 15: Small, scattered platforms with spikes, requiring precise movement.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [100, GAME_WORLD_HEIGHT - 80, 50, 20],
                            [200, GAME_WORLD_HEIGHT - 140, 50, 20],
                            [300, GAME_WORLD_HEIGHT - 200, 50, 20],
                            [400, GAME_WORLD_HEIGHT - 260, 50, 20],
                            [500, GAME_WORLD_HEIGHT - 320, 50, 20],
                            [600, GAME_WORLD_HEIGHT - 380, 200, 20]
                        ],
                        spikes: [
                            [70, GAME_WORLD_HEIGHT - 40, 30, 20],
                            [170, GAME_WORLD_HEIGHT - 100, 30, 20],
                            [270, GAME_WORLD_HEIGHT - 160, 30, 20],
                            [370, GAME_WORLD_HEIGHT - 220, 30, 20],
                            [470, GAME_WORLD_HEIGHT - 280, 30, 20],
                            [570, GAME_WORLD_HEIGHT - 340, 30, 20]
                        ],
                        start_pos: new Vec2(25, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 16: Ground platforms with gaps and elevated platforms in the middle.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 150, 20],
                            [250, GAME_WORLD_HEIGHT - 100, 100, 20],
                            [450, GAME_WORLD_HEIGHT - 100, 100, 20],
                            [650, GAME_WORLD_HEIGHT - 20, 150, 20]
                        ],
                        spikes: [
                            [150, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [350, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [550, GAME_WORLD_HEIGHT - 20, 100, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 17: Similar to Stage 7 but with different spike placements.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [150, GAME_WORLD_HEIGHT - 100, 100, 20],
                            [300, GAME_WORLD_HEIGHT - 180, 100, 20],
                            [450, GAME_WORLD_HEIGHT - 100, 100, 20],
                            [600, GAME_WORLD_HEIGHT - 20, 200, 20]
                        ],
                        spikes: [
                            [175, GAME_WORLD_HEIGHT - 120, 50, 20],
                            [325, GAME_WORLD_HEIGHT - 200, 50, 20],
                            [475, GAME_WORLD_HEIGHT - 120, 50, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 18: Ascending stair-like platforms with more frequent small spikes.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 80, 20],
                            [80, GAME_WORLD_HEIGHT - 60, 80, 20],
                            [160, GAME_WORLD_HEIGHT - 100, 80, 20],
                            [240, GAME_WORLD_HEIGHT - 140, 80, 20],
                            [320, GAME_WORLD_HEIGHT - 180, 80, 20],
                            [400, GAME_WORLD_HEIGHT - 220, 80, 20],
                            [480, GAME_WORLD_HEIGHT - 260, 320, 20]
                        ],
                        spikes: [
                            [80, GAME_WORLD_HEIGHT - 40, 20, 20],
                            [120, GAME_WORLD_HEIGHT - 80, 20, 20],
                            [200, GAME_WORLD_HEIGHT - 120, 20, 20],
                            [280, GAME_WORLD_HEIGHT - 160, 20, 20],
                            [360, GAME_WORLD_HEIGHT - 200, 20, 20],
                            [440, GAME_WORLD_HEIGHT - 240, 20, 20]
                        ],
                        start_pos: new Vec2(40, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 19: Long ground platform with multiple spike sections.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, GAME_WORLD_WIDTH, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 40, 30, 20],
                            [250, GAME_WORLD_HEIGHT - 40, 30, 20],
                            [400, GAME_WORLD_HEIGHT - 40, 30, 20],
                            [550, GAME_WORLD_HEIGHT - 40, 30, 20],
                            [700, GAME_WORLD_HEIGHT - 40, 30, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 20: Ascending platforms with spikes in the gaps.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 80, 20],
                            [150, GAME_WORLD_HEIGHT - 80, 60, 20],
                            [280, GAME_WORLD_HEIGHT - 140, 60, 20],
                            [410, GAME_WORLD_HEIGHT - 200, 60, 20],
                            [540, GAME_WORLD_HEIGHT - 260, 80, 20],
                            [700, GAME_WORLD_HEIGHT - 320, 100, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [200, GAME_WORLD_HEIGHT - 100, 50, 20],
                            [330, GAME_WORLD_HEIGHT - 160, 50, 20],
                            [460, GAME_WORLD_HEIGHT - 220, 50, 20],
                            [590, GAME_WORLD_HEIGHT - 280, 50, 20]
                        ],
                        start_pos: new Vec2(40, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 21: Descending platforms with spikes below.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 80, 20],
                            [150, GAME_WORLD_HEIGHT - 80, 60, 20],
                            [300, GAME_WORLD_HEIGHT - 140, 60, 20],
                            [450, GAME_WORLD_HEIGHT - 200, 60, 20],
                            [600, GAME_WORLD_HEIGHT - 260, 80, 20],
                            [700, GAME_WORLD_HEIGHT - 320, 100, 20]
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [220, GAME_WORLD_HEIGHT - 100, 60, 20],
                            [370, GAME_WORLD_HEIGHT - 160, 50, 20],
                            [480, GAME_WORLD_HEIGHT - 220, 70, 20]
                        ],
                        start_pos: new Vec2(40, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 22: Small, evenly spaced platforms with spikes in between.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [100, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [200, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [300, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [400, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [500, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [600, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [700, GAME_WORLD_HEIGHT - 20, 100, 20]
                        ],
                        spikes: [
                            [50, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [150, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [250, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [350, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [450, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [550, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [650, GAME_WORLD_HEIGHT - 20, 50, 20]
                        ],
                        start_pos: new Vec2(25, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 23: V-shaped platforms with spikes, requiring precise jumps.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [100, GAME_WORLD_HEIGHT - 100, 50, 20],
                            [200, GAME_WORLD_HEIGHT - 180, 50, 20],
                            [300, GAME_WORLD_HEIGHT - 240, 50, 20],
                            [400, GAME_WORLD_HEIGHT - 220, 50, 20],
                            [500, GAME_WORLD_HEIGHT - 120, 50, 20],
                            [600, GAME_WORLD_HEIGHT - 20, 200, 20]
                        ],
                        spikes: [
                            [50, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [150, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [250, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [350, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [450, GAME_WORLD_HEIGHT - 20, 50, 20],
                            [550, GAME_WORLD_HEIGHT - 20, 50, 20]
                        ],
                        start_pos: new Vec2(25, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 24: Two long platforms, one with spikes, the other elevated with spikes.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, GAME_WORLD_WIDTH, 20],
                            [0, GAME_WORLD_HEIGHT - 185, GAME_WORLD_WIDTH, 20] // Further moved down from -130 to -100
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [150, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [250, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [350, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [450, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [550, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [650, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [50, GAME_WORLD_HEIGHT - 165, 50, 20], // Further moved down from -110 to -80
                            [150, GAME_WORLD_HEIGHT - 165, 50, 20],
                            [250, GAME_WORLD_HEIGHT - 165, 50, 20],
                            [350, GAME_WORLD_HEIGHT - 165, 50, 20],
                            [450, GAME_WORLD_HEIGHT - 165, 50, 20],
                            [550, GAME_WORLD_HEIGHT - 165, 50, 20],
                            [650, GAME_WORLD_HEIGHT - 165, 50, 20]
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    },
                    // Stage 25: Very high ascending platforms with spikes, requiring long and precise jumps.
                    {
                        platforms: [
                            [0, GAME_WORLD_HEIGHT - 20, 100, 20],
                            [150, GAME_WORLD_HEIGHT - 100, 60, 20],
                            [250, GAME_WORLD_HEIGHT - 150, 60, 20],
                            [350, GAME_WORLD_HEIGHT - 200, 60, 20], // Moved up from -260
                            [450, GAME_WORLD_HEIGHT - 340, 80, 20], // Moved up from -340
                            [600, GAME_WORLD_HEIGHT - 420, 100, 20]  // Moved up from -420
                        ],
                        spikes: [
                            [100, GAME_WORLD_HEIGHT - 40, 50, 20],
                            [200, GAME_WORLD_HEIGHT - 120, 50, 20],
                            [300, GAME_WORLD_HEIGHT - 170, 50, 20], // Moved up from -200
                            [400, GAME_WORLD_HEIGHT - 360, 50, 20], // Moved up from -280
                            [500, GAME_WORLD_HEIGHT - 440, 50, 20]  // Moved up from -360
                        ],
                        start_pos: new Vec2(50, GAME_WORLD_HEIGHT - PLAYER_START_Y_OFFSET)
                    }
                ];

                this.NUM_BASE_PATTERNS = this.BASE_STAGE_PATTERNS.length; // 修正: PATTERNS に修正
                this.TOTAL_STAGES = 25;

                this.loadStage(this.currentStageIndex);
            }

            loadStage(index) {
                if (index >= this.TOTAL_STAGES) {
                    gameState = GAME_STATE_CLEAR;
                    console.log("ゲームクリア！おめでとうございます！");
                    gameClearScreen.style.display = 'flex';
                    return;
                }

                this.currentStageIndex = index;
                stageDisplay.textContent = `Stage: ${this.currentStageIndex + 1}`;
                gameClearScreen.style.display = 'none'; // Ensure clear screen is hidden

                const stageConfig = this.BASE_STAGE_PATTERNS[index % this.NUM_BASE_PATTERNS];

                this.platforms = [];
                this.spikes = [];

                stageConfig.platforms.forEach(p => {
                    this.platforms.push(new Platform(p[0], p[1], p[2], p[3]));
                });

                stageConfig.spikes.forEach(s => {
                    this.spikes.push(new Spike(s[0], s[1], s[2], s[3]));
                });

                this.player.pos = stageConfig.start_pos.copy();
                this.player.vel = new Vec2(0, 0);
                this.player.acc = new Vec2(0, 0);
                this.player.onGround = false;
                this.playerStartPosCurrentStage = stageConfig.start_pos.copy();
            }

            nextStage() {
                this.loadStage(this.currentStageIndex + 1);
            }

            resetCurrentStage() {
                console.log(`リセット！ステージ ${this.currentStageIndex + 1} の最初に戻ります。`);
                this.player.pos = this.playerStartPosCurrentStage.copy();
                this.player.vel = new Vec2(0, 0);
                this.player.acc = new Vec2(0, 0);
                this.player.onGround = false;
                gameClearScreen.style.display = 'none'; // Ensure clear screen is hidden on reset
            }
        }

        const gameManager = new GameManager();
        const keysPressed = {};
        
        // Function to control button visibility and pointer events
        function setButtonVisibility(visible) {
            if (visible) {
                onScreenControls.style.display = 'flex';
                onScreenControls.style.pointerEvents = 'auto'; // Enable pointer events
            } else {
                onScreenControls.style.display = 'none';
                onScreenControls.style.pointerEvents = 'none'; // Disable pointer events
            }
        }

        // Initial state: buttons visible
        setButtonVisibility(true);

        // --- Gamepad Event Listeners ---
        window.addEventListener("gamepadconnected", (e) => {
            console.log("Gamepad connected at index %d: %s. %d buttons, %d axes.",
                e.gamepad.index, e.gamepad.id,
                e.gamepad.buttons.length, e.gamepad.axes.length);
            gamepadIndex = e.gamepad.index;
            inputMode = 'gamepad';
            setButtonVisibility(false); // Hide on-screen buttons when gamepad connects
        });

        window.addEventListener("gamepaddisconnected", (e) => {
            console.log("Gamepad disconnected from index %d: %s",
                e.gamepad.index, e.gamepad.id);
            if (gamepadIndex === e.gamepad.index) {
                gamepadIndex = null;
                inputMode = 'touch'; // Revert to touch mode if gamepad disconnected
                setButtonVisibility(true); // Show on-screen buttons
            }
        });

        // --- Keyboard Event Listeners ---
        document.addEventListener('keydown', (e) => {
            if (inputMode !== 'keyboard') { // Only switch mode if not already in keyboard mode
                inputMode = 'keyboard';
                setButtonVisibility(false); // Hide buttons
            }
            keysPressed[e.key] = true;
            if (gameState === GAME_STATE_PLAYING) {
                if (e.key === 'ArrowUp' || e.key === 'w') {
                    gameManager.player.jump();
                }
                if (e.key === ' ' && e.shiftKey) { // Debug next stage
                    gameManager.nextStage();
                }
            } else if (gameState === GAME_STATE_CLEAR) {
                gameClearScreen.style.display = 'none'; // Hide clear screen immediately on restart attempt
                gameManager.currentStageIndex = 0;
                gameState = GAME_STATE_PLAYING;
                gameManager.loadStage(gameManager.currentStageIndex);
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
            // Input mode is not changed on keyup, only on keydown or touch/gamepad input
        });

        // --- On-screen Button Event Handlers ---
        // Function to handle button press (both mouse and touch)
        function handleButtonPress(key) {
            if (gameState === GAME_STATE_PLAYING) {
                // If a button is pressed, assume touch mode and show buttons
                if (inputMode !== 'touch') {
                    inputMode = 'touch';
                    setButtonVisibility(true); // Show buttons
                }
                keysPressed[key] = true;
                if (key === 'ArrowUp') { // Only jump on press, not continuous hold
                    gameManager.player.jump();
                }
            }
        }

        // Function to handle button release (both mouse and touch)
        function handleButtonRelease(key) {
            if (gameState === GAME_STATE_PLAYING) {
                keysPressed[key] = false;
            }
        }

        // Attach event listeners for each on-screen button
        // Left Button
        leftButton.addEventListener('mousedown', () => handleButtonPress('ArrowLeft'));
        leftButton.addEventListener('mouseup', () => handleButtonRelease('ArrowLeft'));
        leftButton.addEventListener('mouseleave', () => handleButtonRelease('ArrowLeft')); // If mouse drags off button
        leftButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleButtonPress('ArrowLeft'); }, { passive: false });
        leftButton.addEventListener('touchend', (e) => { e.preventDefault(); handleButtonRelease('ArrowLeft'); }, { passive: false });

        // Right Button
        rightButton.addEventListener('mousedown', () => handleButtonPress('ArrowRight'));
        rightButton.addEventListener('mouseup', () => handleButtonRelease('ArrowRight'));
        rightButton.addEventListener('mouseleave', () => handleButtonRelease('ArrowRight'));
        rightButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleButtonPress('ArrowRight'); }, { passive: false });
        rightButton.addEventListener('touchend', (e) => { e.preventDefault(); handleButtonRelease('ArrowRight'); }, { passive: false });

        // Jump Button
        jumpButton.addEventListener('mousedown', () => handleButtonPress('ArrowUp'));
        jumpButton.addEventListener('mouseup', () => handleButtonRelease('ArrowUp'));
        jumpButton.addEventListener('mouseleave', () => handleButtonRelease('ArrowUp'));
        jumpButton.addEventListener('touchstart', (e) => { e.preventDefault(); handleButtonPress('ArrowUp'); }, { passive: false });
        jumpButton.addEventListener('touchend', (e) => { e.preventDefault(); handleButtonRelease('ArrowUp'); }, { passive: false });

        // --- Canvas Mouse/Touch Listeners (for re-showing buttons or game clear) ---
        canvas.addEventListener('mousedown', (e) => {
            e.preventDefault();
            if (gameState === GAME_STATE_PLAYING) {
                // If not in touch mode, a click on canvas should switch to touch mode and show buttons
                if (inputMode !== 'touch') {
                    inputMode = 'touch';
                    setButtonVisibility(true); // Show buttons
                }
            } else if (gameState === GAME_STATE_CLEAR) {
                gameClearScreen.style.display = 'none'; // Hide clear screen immediately on restart attempt
                gameManager.currentStageIndex = 0;
                gameState = GAME_STATE_PLAYING;
                gameManager.loadStage(gameManager.currentStageIndex);
            }
        });

        canvas.addEventListener('mouseup', (e) => {
            e.preventDefault();
            // No specific action needed on mouseup for input mode
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (gameState === GAME_STATE_PLAYING) {
                // If not in touch mode, a touch on canvas should switch to touch mode and show buttons
                if (inputMode !== 'touch') {
                    inputMode = 'touch';
                    setButtonVisibility(true); // Show buttons
                }
            } else if (gameState === GAME_STATE_CLEAR) {
                gameClearScreen.style.display = 'none'; // Hide clear screen immediately on restart attempt
                gameManager.currentStageIndex = 0;
                gameState = GAME_STATE_PLAYING;
                gameManager.loadStage(gameManager.currentStageIndex);
            }
        }, { passive: false });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            // No specific action needed on touchend for input mode
        });

        // --- Gamepad Polling Function ---
        function pollGamepads() {
            if (gamepadIndex !== null) {
                const gamepads = navigator.getGamepads();
                const gamepad = gamepads[gamepadIndex];

                if (gamepad) {
                    // Reset keyboard/touch inputs if gamepad is active
                    if (inputMode !== 'gamepad') {
                        inputMode = 'gamepad';
                        setButtonVisibility(false);
                    }

                    // Map gamepad axes for horizontal movement (Left Stick X-axis or D-pad)
                    const leftStickX = gamepad.axes[0]; // Standard for left stick horizontal
                    const dPadLeft = gamepad.buttons[14]; // D-pad Left (common)
                    const dPadRight = gamepad.buttons[15]; // D-pad Right (common)

                    keysPressed['ArrowLeft'] = (leftStickX < -0.5 || (dPadLeft && dPadLeft.pressed));
                    keysPressed['ArrowRight'] = (leftStickX > 0.5 || (dPadRight && dPadRight.pressed));

                    // Map gamepad button for jump (e.g., A button on Xbox, Cross on PlayStation)
                    const jumpButton = gamepad.buttons[0]; // Common 'A' or 'X' button

                    // Trigger jump only on press, not continuous hold
                    if (jumpButton && jumpButton.pressed && !gamepad.lastJumpButtonPressed) {
                        gameManager.player.jump();
                    }
                    gamepad.lastJumpButtonPressed = (jumpButton && jumpButton.pressed);

                    // Handle game clear screen restart with gamepad (e.g., Start button or A button)
                    const startButton = gamepad.buttons[9]; // Common Start button
                    if (gameState === GAME_STATE_CLEAR && (startButton && startButton.pressed) && !gamepad.lastStartButtonPressed) {
                         gameClearScreen.style.display = 'none';
                         gameManager.currentStageIndex = 0;
                         gameState = GAME_STATE_PLAYING;
                         gameManager.loadStage(gameManager.currentStageIndex);
                    }
                    gamepad.lastStartButtonPressed = (startButton && startButton.pressed);

                } else {
                    // Gamepad was connected but is no longer available (e.g., unplugged)
                    gamepadIndex = null;
                    inputMode = 'touch';
                    setButtonVisibility(true);
                }
            }
        }


        // Game Loop
        function gameLoop() {
            pollGamepads(); // Check gamepad input every frame

            if (gameState === GAME_STATE_PLAYING) {
                ctx.fillStyle = '#87CEEB';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                gameManager.player.update(gameManager.platforms, gameManager.spikes, gameManager, keysPressed);
                gameManager.platforms.forEach(platform => platform.draw());
                gameManager.spikes.forEach(spike => spike.draw());
                gameManager.player.draw();
            }
            requestAnimationFrame(gameLoop);
        }

        gameLoop();
    </script>
</body>
</html>
